<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nikola Stoyanov on Nikola Stoyanov</title>
    <link>https://nikstoyanov.me/</link>
    <description>Recent content in Nikola Stoyanov on Nikola Stoyanov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Dec 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Regularization of ill-posed problems</title>
      <link>https://nikstoyanov.me/post/2018-12-29-regularization-illposed/</link>
      <pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nikstoyanov.me/post/2018-12-29-regularization-illposed/</guid>
      <description>&lt;p&gt;Recently I had to reconstruct a solution for the thermal boundary between boiling cryogenic liquid and a steel plate. The temperature of the cryogenic-steel boundary is extremely difficult to measure experimentally since the mere presence of the thermocouples would affect the nucleation of bubbles which in turn affect the heat extraction. Also modeling the boiling phenomena is a great computational challenge which is too great of a topic to undertake for this problem. An easier way would be to perform an experiment and measure the temperature at the bottom of the plate. We can then build a direct numerical model which predicts those temperatures and reconstruct the exposure by iterating the initial guess. In this post I will present the Tikhonov regularization method which is used to solve the ill-posed problem.&lt;/p&gt;

&lt;h1 id=&#34;direct-problem&#34;&gt;Direct problem&lt;/h1&gt;

&lt;p&gt;In theory inversing the heat equation sounds great, however, the direct numerical implementation would inevitable lead to an ill-posed problem which we cannot solve. To illustrate lets consider the one dimensional heat transfer problem. We want to reconstruct temperatures $T(x, t=t_{0})$ in the past, based on present-day measurements $T(x, t=t_{1})$. In this model we consider the diffusion problem only without and external heat generation or internal heat generation. The heat equation is then given by the parabolic partial differential equation below.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
\frac{\partial T}{\partial t} = u \frac{\partial^{2} T}{\partial x^{2}}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Where $T$ is temperature, $t$ is time, $u$ is a constant to represent the material properties and $x$ is the length dimension. The equation represents the balance of energy between the capacitive term $\partial T/\partial t$ and the diffusion $\partial T^{2}/\partial x^{2}$ i.e. the heat transfered through diffusion is responsible for the temperature change.&lt;/p&gt;

&lt;p&gt;Lets impose a periodic boundary condition.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
T(x+L, t) = T(x, t)
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The heat equation can be solved by a simple finite difference explicit scheme as below.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
\frac{\Delta T_{n}}{\Delta t} = u \frac{T_{n-1} - T_{n}}{\Delta x^{2}} - u \frac{T_{n} - T_{n+1}}{\Delta x^{2}}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The equation can be vectorized and we can incorporate the boundary condition in the matrix L to handle the internal and external nodes.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
\frac{\Delta T}{\Delta t} = u \frac{L T}{\Delta x^{2}}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The linear combination of the equations can then be rewritten by combining the boundary condition, $L$ and the material properties, $u$ as below.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
T_{t+1} = A T_{t}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Explicit schemes have issues with numerical stability and require limiting values of the mesh size, $\Delta x$ and time step, $t$. For those interested, the reason is the we are solving a direct system of equations and we need to allow enough time, $(t)$ for the information to propagate from cell to cell, $(\Delta x)$. The critical relationship is known as the Courant–Friedrichs–Lewy (CFL) condition and we would need to check that it is satisfied.&lt;/p&gt;

&lt;p&gt;If we chose the values of the constants the above equation can be solved directly. In fact this is known as the direct problem.&lt;/p&gt;

&lt;p&gt;The finite difference method can be conveniently implemented using a Toeplitz matrix to approximate the derivatives. The matrix is build using constant value descending diagonals from left to right. The matrix can be represented as&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
\begin{bmatrix}
a &amp; b &amp; c &amp; d \\
d &amp; a &amp; b &amp; c \\
c &amp; d &amp; a &amp; b \\
d &amp; c &amp; b &amp; a \\
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Our simple discretization scheme is using forward difference for the time and central difference for the space, so lets implement it.&lt;/p&gt;

&lt;p&gt;We will use numpy and scipy for our work.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[1]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import scipy.linalg
import numpy as np
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The domain is discretised using $n=15$ elements and the time step is $t=2\times 10^{1}$. The Tikhonov regularization temr is given by $w=1\times 10^{-2}$.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[2]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n = 40
t = 1e1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then apply the boundary condition using the Toeplitz matrix.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[3]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;A = np.zeros((1, n))
A[0, 0] = -1
A[0, 1] = 0.5
A[0, -1] = 0.5
L = scipy.linalg.toeplitz(A)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let us check the CFL condition for our chosen constants.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[4]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;t/n &amp;lt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[4]:&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;all seems okay, we can then calculate the matrix $A$.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[5]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;A = scipy.linalg.fractional_matrix_power(np.eye(n) + L, t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The initial condition is then set to provide us with a problem that is interesting to recover.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[6]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = np.arange(0, n)
Tt = np.sin(3*np.pi * x / n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then calculate the direct problem $T_{t+1} = A T_{t}$.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[7]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Tfwd = np.dot(A, Tt)
Tfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[7]:&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;array([ 0.48258534,  0.52670091,  0.54171091,  0.62253495,  0.66895761,
        0.73312732,  0.75678431,  0.75913893,  0.71954341,  0.64474529,
        0.53431844,  0.39482101,  0.23350572,  0.05928686, -0.1182082 ,
       -0.28917105, -0.44415427, -0.57459345, -0.67328051, -0.73476198,
       -0.75564038, -0.73476198, -0.67328051, -0.57459345, -0.44415427,
       -0.28917105, -0.1182082 ,  0.05928686,  0.23350572,  0.39482101,
        0.53431844,  0.64474529,  0.71954341,  0.75913893,  0.75678431,
        0.73312732,  0.66895761,  0.62253495,  0.54171091,  0.52670091])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;The solution, $T_{t+1}$ is then visualized and it can be seen that, $T_{t}$ has diffused towards the 0 temperature condition.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[8]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
from IPython.display import set_matplotlib_formats
%matplotlib inline
set_matplotlib_formats(&#39;svg&#39;)

plt.plot(x, Tt, label=&#39;$T_{t}$&#39;)
plt.plot(x, Tfwd, label=&#39;$T_{t+1}$&#39;)

plt.legend()
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[8]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./regularization-illposed_33_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h1 id=&#34;inverse-problem&#34;&gt;Inverse problem&lt;/h1&gt;

&lt;p&gt;The interesting question then becomes: what if we already know the values of $T_{t+1}$ and want to find what $T_{t}$ was? Such a case can be that we have measured the temperature and we are trying to figure out what the temperature used to be before. Naively we can try to inverse the matrix $A$.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
T_{t} = A^{-1} T_{t+1}
\]&lt;/span&gt;&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[9]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Tinv = np.dot(np.linalg.inv(A), Tfwd)
Tinv
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[9]:&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;array([ 6.800e+01, -2.000e+00, -3.560e+02, -4.000e+00,  9.160e+02,
        3.000e+01, -1.632e+03, -2.200e+01,  2.192e+03, -2.400e+01,
       -2.288e+03,  9.600e+01,  1.920e+03, -1.880e+02, -1.304e+03,
        2.540e+02,  7.400e+02, -2.680e+02, -3.680e+02,  2.120e+02,
        1.680e+02, -1.280e+02, -7.200e+01,  5.200e+01,  1.600e+01,
       -1.600e+01,  8.000e+00, -2.000e+00, -1.600e+01,  0.000e+00,
        4.000e+00,  0.000e+00, -4.000e+00,  6.000e+00, -1.200e+01,
       -2.000e+00,  8.000e+00,  4.000e+00, -8.000e+00,  0.000e+00])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;We have obtained the inverse matrix. Lets check if we can recover the identity matrix, $I$, even though in this case a visual inspection tells me that something is not right. We are expecting to obtain the equation below.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
A^{-1}A = I
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;We will see that for our case we would not be able to recover it which means that our inversion did not work satisfactory. In other words during the inversion the condition number of the matrix $A$ is so large that the rounding errors are amplified to the point where the errors dominate the solution.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[10]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;np.allclose(np.dot(A, np.linalg.inv(A)), np.eye(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[10]:&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;As expected our matrix is ill-conditioned and direct inversion did not provide satisfactory results. Lets check the condition number.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[11]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;np.linalg.cond(A)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[11]:&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;3.249636913192119e+16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;This is a huge number! The problem arises if the condition number is greater than the machine precision.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[12]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;np.linalg.cond(A) &amp;gt; np.finfo(A.dtype).eps
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[12]:&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;It seems that this is a wrong approach to use. The condition number is orders of magnitude larger and the errors speak for themselves. In the plot below we are expecting $T_{t}$ and $T_{inv}$ to match.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[13]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.plot(x, Tt, label=&#39;$T_{t}$&#39;)
plt.plot(x, Tinv, label=&#39;$T_{inv}$&#39;)

plt.legend()
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[13]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./regularization-illposed_47_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;We have clearly not been able to recover $T_{t}$ from the naive method of inversion.&lt;/p&gt;

&lt;h1 id=&#34;tikhonov-regularization&#34;&gt;Tikhonov Regularization&lt;/h1&gt;

&lt;p&gt;Tikhonov regularization, with small modification known as Ridge regression in statistics or Weight decay in machine learning can solve the problem by imposing a penalty term $\lambda$. Such problems can be formulated as&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
\begin{align}
\text{Minimize } &amp; ||A T_{t} - T_{fwd}||_{2}^{2} + \lambda ||LT_{t}||^{2}_{2} \\
\text{Subject to } &amp; A \geq 0
\end{align}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;This can be done using a linear least squares solver by $lstsq(B, C)$ where we can implement the Tikhonov regularization in the arguments. For reference, the least squares solver expects problems of the type below.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
\text{Minimize } ||AT_{t} - T_{fwd}||_{2}^{2}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The arguments been to be modified as such:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
B = \begin{bmatrix}
A\\
\lambda L
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
C = \begin{bmatrix}
T_{fwd}\\
L \times 0\\
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;We also need a function to calculate the $R^{2}$ of the fit.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[22]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from scipy.stats import linregress

def rsqr(x, y):
    slope, intercept, r_value, p_value, std_err = linregress(x, y)
    return r_value**2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem can then be solved.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[27]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;classifiers = [100, 50, 15, 5, 1, 0.1]
r_squared = []

C = np.concatenate([Tfwd, np.zeros(n)])

fig, ax = plt.subplots(2, 1, figsize=(7.5, 10))
for tikhonov in classifiers:
    B = np.concatenate([A, tikhonov*L])
    T_lstqs =  np.linalg.lstsq(B, C, rcond=None)
    ax[0].scatter(x, T_lstqs[0], label=&amp;quot;$\lambda=$&amp;quot; + str(tikhonov))
    
    r_squared.append(rsqr(Tt, T_lstqs[0]))
    ax[1].scatter(tikhonov, r_squared[-1], label=&amp;quot;$\lambda=$&amp;quot; + str(tikhonov))

ax[0].plot(x, Tt, label=&#39;$T_{t}$&#39;, linewidth=2.5, color=&#39;black&#39;)
ax[0].legend()

ax[1].plot(classifiers, r_squared)
ax[1].legend()
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[27]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./regularization-illposed_61_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;We can see that the results converge towards $T_{t}$ as $\lim_{\lambda \to 0} T(\lambda)$.&lt;/p&gt;

&lt;h1 id=&#34;lstsq-solution&#34;&gt;lstsq Solution&lt;/h1&gt;

&lt;p&gt;For completeness I want to show that we can straight up use $lstsq$ to solve the problem without going in any detail about regularization. However, in doing this we don&#39;t learn anything new and we will see in further posts that Tikhonov regularization is indeed needed for solving the bigger optimization problem which is the temperature recovery through the thickness of the specimen to obtain the surface temperature.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[16]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Tls = np.linalg.lstsq(A, Tfwd, rcond=None)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[17]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.scatter(x, Tls[0], label=&#39;Tls&#39;)
plt.plot(x, Tt, label=&#39;$T_{t}$&#39;)
plt.legend()
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[17]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./regularization-illposed_66_0.svg&#34; alt=&#34;svg&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Which gives a very good fit!&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[18]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rsqr(Tt, Tls[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[18]:&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;0.9998417880466148
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;We have implemented Tikhonov regularization to solve an ill-conditioned inverse problem. Now we can recover temperatures from previous time steps by only using the current results. Stay tuned for the next posts where I will implement the above solution technique to recover temperatures on the exposed surface by readings from thermocouples located in the depth.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example Page</title>
      <link>https://nikstoyanov.me/tutorial/example/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 +0100</pubDate>
      
      <guid>https://nikstoyanov.me/tutorial/example/</guid>
      <description>

&lt;p&gt;In this tutorial, I&amp;rsquo;ll share my top 10 tips for getting started with Academic:&lt;/p&gt;

&lt;h2 id=&#34;tip-1&#34;&gt;Tip 1&lt;/h2&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;tip-2&#34;&gt;Tip 2&lt;/h2&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploring Fractals</title>
      <link>https://nikstoyanov.me/post/2018-08-02-exploring-fractals/</link>
      <pubDate>Tue, 28 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nikstoyanov.me/post/2018-08-02-exploring-fractals/</guid>
      <description>&lt;p&gt;I recently rewatched a &lt;a href=&#34;https://www.youtube.com/watch?v=Lk6QU94xAb8&#34;&gt;video&lt;/a&gt; from Arthur C. Clarke which is where I
first saw what fractals are. I saw this video while I was in high
school and having rewatched it now I wondered if I can generate the
Mandelbrot set and explore some parts of it myself. I did a quick
search online and I discovered that &lt;a href=&#34;https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift?lang=en&#34;&gt;Jean Francois Puget&lt;/a&gt; had already
done that and achieved great results. Learning from his work I decided
to do some computational experiments.&lt;/p&gt;

&lt;p&gt;For this post I will use the acceleration provided by &lt;em&gt;numba&lt;/em&gt; as in the
original post by &lt;a href=&#34;https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift?lang=en&#34;&gt;Jean Francois Puget&lt;/a&gt;. In a further post he developed a
parallel version of the code so you can check it out, but for my
purposes now &lt;em&gt;numba&lt;/em&gt; will be enough.&lt;/p&gt;

&lt;h1 id=&#34;fractals&#34;&gt;Fractals&lt;/h1&gt;

&lt;p&gt;Fractals are abstract objects that are infinitely complicated and
exhibit similar patterns at increasingly smaller scales. What this
means is that we can keep zooming in the fractal until the original
picture is bigger than the visible universe and still see
patterns. For this post I want to explore the Mandelbrot set and
produce the fractal from it. However, before delving in the Mandelbrot
set we need to look at the more general picture.&lt;/p&gt;

&lt;p&gt;The Mandelbrot set is made by iteration using the simple formula
&lt;span  class=&#34;math&#34;&gt;\(z_{n+1} = z_n^2 + c\)&lt;/span&gt; for different values of $c$ in the complex
plane. Then we have two possible paths: the iteration will converge or
diverge. Points on the complex plane $\mathbb{C}$ for which $z_n$ is
bounded form the Mandelbrot set. Points which are not bounded do not
belong to the Mandelbrot set and to get artistic pictures are usually
coloured based on how fast they change. Each point $c$ then specifies
the geometric structure of the corresponding Julia set.&lt;/p&gt;

&lt;p&gt;Julia sets are formed by performing a repeated iteration of a
holomorphic function and in this post we will investigate polynomial
functions of the form $z_{n+1} = z_{n}^2 + c$. The set has an
interesting property of chaotic behaviour which produces drastically
different result from a small perturbation. The Julia set also has a
complementary set known as the Fatou set which has the property that
all values behave similarly under the repeated iteration. Now if a
point $c$ is in the Mandelbrot set the Julia set is called connected,
if it is not then it is known as Cantor/Fatou dust.&lt;/p&gt;

&lt;p&gt;We can now visualise what we mean by the above by using some Python
code and the Scipy library.&lt;/p&gt;

&lt;h1 id=&#34;mandelbrot-set&#34;&gt;Mandelbrot Set&lt;/h1&gt;

&lt;p&gt;The Mandelbrot set is generated using the iterative formula below.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[z_{n+1} = z_{n}^{2} + c\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;To get the set we start from $z_{0} = 0$ for a given $c$
coordinate. Expressing it mathematically, for a point to belong to the
Mandelbrot set we need the limit to be $\leq 2$. The precise reason is
given below.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[c \in M \iff \lim_{n \to \infty} \sup|z_{n+1}| \leq 2\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;When I first saw the mathematical description I could not understand
why was the number 2 written as the upper boundary to determine if a
point belongs to the Mandelbrot set or not. I decided to dig further
and I found the mathematical proof. I found the explanation in &lt;a href=&#34;http://www.alunw.freeuk.com/mandelbrotroom.html&#34;&gt;Alun
Williams&#39;&lt;/a&gt; website and you can read it there.&lt;/p&gt;

&lt;p&gt;Lets define the function for the Mandelbrot set.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[1]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
from numba import jit

@jit
def mandelbrot(c, maxiter):
    z = c
    
    for n in range(maxiter):
        if abs(z) &amp;gt; 2:
            return n
        z = z*z + c
    return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The holomorphic function can then be called to generate the Mandelbrot
set. I will take this opportunity to generalise the set generation and
plot functions so we can use them with the Julia set as well.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[2]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@jit
def generate_set(set_function, xmin, xmax, ymin, ymax, width, height, maxiter):
    r1 = np.linspace(xmin, xmax, width)
    r2 = np.linspace(ymin, ymax, height)
    n3 = np.empty((width,height))
    
    for i in range(width):
        for j in range(height):
            n3[i, j] = set_function(r1[i] + 1j * r2[j], maxiter)
    return (r1, r2, n3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having generated the set we need a way to visualise it. We can do this
with Matplotlib. As states above the algorithm to display the fractals
is explained &lt;a href=&#34;https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift?lang=en&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[3]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from matplotlib import pyplot as plt
from matplotlib import colors
from matplotlib import patches
from IPython.display import set_matplotlib_formats
%matplotlib inline
set_matplotlib_formats(&#39;png&#39;)

def generate_image(set_function, xmin, xmax, ymin, ymax, width=10, height=10, maxiter=256):
    dpi = 72
    img_width = dpi * width
    img_height = dpi * height
    x,y,z = generate_set(set_function, xmin, xmax, ymin, ymax, img_width, img_height, maxiter)
    
    fig, ax = plt.subplots(figsize=(width, height), dpi=72)
    ticks = np.arange(0, img_width, 3*dpi)
    x_ticks = xmin + (xmax-xmin)*ticks/img_width
    plt.xticks(ticks, x_ticks)
    y_ticks = ymin + (ymax-ymin)*ticks/img_width
    plt.yticks(ticks, y_ticks)
    
    ax.imshow(z.T, origin=&#39;lower&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then visualise the Mandelbrot set.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[4]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;generate_image(mandelbrot, -2.0, 0.5, -1.25, 1.25)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[4]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_20_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;The &amp;quot;main&amp;quot; part of the Mandelbrot is called the main cardioid and the
set contains small copies of itself connected to the main
cardioid. This continues and we get structures which resemble hairs,
not surprisingly these features are called Mandelbrot hair.&lt;/p&gt;

&lt;p&gt;Other explorers have discovered interesting anchor points. For example
lets set sail to $-0.761574-i0.0847596$ as shown on maps generated by
&lt;a href=&#34;http://paulbourke.net/fractals/mandelbrot/&#34;&gt;Paul Bourke&lt;/a&gt;. We will centre at this point and zoom $\times 10$ to
start with. Note that the original generated image is of size
$2.5\times2.5$ and we need a function to generate the size of the
image for the given zoom.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[5]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def zoom_image(xc, yc, size):
    x1 = xc - size
    x2 = xc + size
    y1 = yc - size
    y2 = yc + size
    return x1, x2, y1, y2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can than choose our point of interest and zoom into it.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[6]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;xc = -0.761574
yc = -0.0847596
size = 2.5 / 10

x1, x2, y1, y2 = zoom_image(xc, yc, size)
generate_image(mandelbrot, x1, x2, y1, y2)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[6]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_24_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Great, everything is looking fine. We can see the primary continental
mu-atom and a mu-atom of period 2, if you want an explanation of the
names go &lt;a href=&#34;https://www.mrob.com/pub/muency/r2.html&#34;&gt;here&lt;/a&gt;. The place in the middle where all the interesting
features occur is know as the &lt;a href=&#34;https://www.mrob.com/pub/muency/seahorsevalley.html&#34;&gt;seahorse valley&lt;/a&gt; and we are going to
explore the southern part. Lets zoom $\times 500$ and explore the
seahorses.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[7]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;size = 2.5 / 500

x1, x2, y1, y2 = zoom_image(xc, yc, size)
generate_image(mandelbrot, x1, x2, y1, y2)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[7]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_26_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;We can see why mathematicians are referring to these patters as
seahorses. Also notice that more patterns are starting to emerge as we
go deeper in the set. Why stop now, $\times 1000$ it is.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[8]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;size = 2.5 / 1000

x1, x2, y1, y2 = zoom_image(xc, yc, size)
generate_image(mandelbrot, x1, x2, y1, y2)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[8]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_28_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;I will test the ability of our code to cope with even more decimals
places and zoom to $\times 15625$. We can then compare with the image
obtained from &lt;a href=&#34;http://paulbourke.net/fractals/mandelbrot/&#34;&gt;Paul Bourke&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[9]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;size = 2.5 / 15625

x1, x2, y1, y2 = zoom_image(xc, yc, size)
generate_image(mandelbrot, x1, x2, y1, y2)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[9]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_30_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Okay, lets go wild and do a $5\times10^6$ zoom.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[10]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;size = 2.5 / (5 * (10**6))

x1, x2, y1, y2 = zoom_image(xc, yc, size)
generate_image(mandelbrot, x1, x2, y1, y2)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[10]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_32_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Whoops, it seems that we have reached the limit of the colouring
algorithm. This is an issue for another post, where I am planning to
program the problem in C++ and use different generation and colouring
algorithms.&lt;/p&gt;

&lt;h1 id=&#34;julia-set&#34;&gt;Julia Set&lt;/h1&gt;

&lt;p&gt;To generate a Julia set we need a &lt;a href=&#34;https://en.wikipedia.org/wiki/Holomorphic_function&#34;&gt;holomorphic function&lt;/a&gt;. In other words
we need a continuously differentiable complex-valued function with one
or more complex variable. Lets start with something random... the
first thing that comes to mind.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[f(z) = z^3 + c\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The iteration is then performed for:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[z_{n+1} = z_{n}^{3} + c\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;We can then get the points that tend to infinity, those that do not
(Fatou set) and the boundary between them (Julia set) for a complex
number $k$ if we set $c=k$ and start with $z_{0}$ as the coordinates
of a point. Lets explore $c = -0.1 + i0.65$ which is in the Mandelbrot
set and we would get a connected Julia set. The way I have implemented this is to define a holomorphic function
with a given complex parameter $c$, the seemingly weird use of $c$ as
an argument to define $z$ and then be redefined is just for
convenience so I can use the same set generation function as for the
Mandelbrot set.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[11]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@jit
def holomorphic_julia(c, maxiter):
    z = c
    c = complex(-0.1, 0.65)
    
    for n in range(maxiter):
        if abs(z) &amp;gt; 10:
            return n
        z = z*z + c
    return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then show our results and we get a weird looking bulge.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[12]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;generate_image(holomorphic_julia, -1.5, 1.5, -1.5, 1.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[12]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_42_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Lets examine the fractal nature of this thing we have produced. We
would focus in the middle of our bulge.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[13]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;xc = 0.0
yc = 0.0
size = 3.0 / 10

x1, x2, y1, y2 = zoom_image(xc, yc, size)
generate_image(holomorphic_julia, x1, x2, y1, y2)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[13]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_44_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;We can see that we have generated a fractal since zooming in reveals
similar patterns of infinity complexity. We can also see the Julia
set as the boundary between the Fatou sets.&lt;/p&gt;

&lt;p&gt;Now we can pick a point which is outside of the Mandelbrot set. Such a
point is $c = -2.5 - i2.5$.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[14]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@jit
def holomorphic_candor_dust(c, maxiter):
    z = c
    c = complex(-2.5, -2.5)
    
    for n in range(maxiter):
        if abs(z) &amp;gt; 10:
            return n
        z = z*z + c
    return 0

generate_image(holomorphic_candor_dust, -4.0, 4.0, -4.0, 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[14]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_46_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;This is known as Cantor/Fatou dust and the calculation oscillates
between the points on the plot which is very different from the
previous Julia set. As can be seen the resultant behaviour is very
much dependent on whether $c$ is in the Mandelbrot set or not.  We can
also investigate different complex parameters. For example lets see a
$c = -0.78 + 0.1i$ which is in the Mandelbrot set and the function
$z_{n+1} = z_{n}^{2} + c$ as shown &lt;a href=&#34;https://ibmathsresources.com/2015/03/29/mandelbrot-and-julia-sets-pictures-of-infinity/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;prompt input_prompt&#34;&gt;In&amp;nbsp;[15]:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@jit
def holomorphic_julia_spinning_eyes(c, maxiter):
    z = c
    c = complex(-0.78, 0.1)
    
    for n in range(maxiter):
        if abs(z) &amp;gt; 10:
            return n
        z = z*z + c
    return 0

generate_image(holomorphic_julia_spinning_eyes,  -1.5, 1.5, -1.5, 1.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;output_area&#34;&gt;

&lt;div class=&#34;prompt output_prompt&#34;&gt;Out[15]:&lt;/div&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;./exploring-fractals_48_0.png&#34; alt=&#34;png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Thank you for reading!!! I hope this was a fun post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example Talk</title>
      <link>https://nikstoyanov.me/talk/example/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://nikstoyanov.me/talk/example/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;Click on the &lt;strong&gt;Slides&lt;/strong&gt; button above to view the built-in slides feature.&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Slides can be added in a few ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create&lt;/strong&gt; slides using Academic&amp;rsquo;s &lt;em&gt;Slides&lt;/em&gt; feature and link using &lt;code&gt;url_slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upload&lt;/strong&gt; an existing slide deck to &lt;code&gt;static/&lt;/code&gt; and link using &lt;code&gt;url_slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embed&lt;/strong&gt; your slides (e.g. Google Slides) or presentation video on this page using &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34; target=&#34;_blank&#34;&gt;shortcodes&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Further talk details can easily be added to this page using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>External Project</title>
      <link>https://nikstoyanov.me/project/external-project/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0100</pubDate>
      
      <guid>https://nikstoyanov.me/project/external-project/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Internal Project</title>
      <link>https://nikstoyanov.me/project/internal-project/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0100</pubDate>
      
      <guid>https://nikstoyanov.me/project/internal-project/</guid>
      <description>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.&lt;/p&gt;

&lt;p&gt;Nullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.&lt;/p&gt;

&lt;p&gt;Cras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.&lt;/p&gt;

&lt;p&gt;Suspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.&lt;/p&gt;

&lt;p&gt;Aliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Person Re-Identification System For Mobile Devices</title>
      <link>https://nikstoyanov.me/publication/person-re-id/</link>
      <pubDate>Tue, 01 Sep 2015 00:00:00 +0100</pubDate>
      
      <guid>https://nikstoyanov.me/publication/person-re-id/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mobile visual clothing search</title>
      <link>https://nikstoyanov.me/publication/clothing-search/</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 +0100</pubDate>
      
      <guid>https://nikstoyanov.me/publication/clothing-search/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides</title>
      <link>https://nikstoyanov.me/slides/example-slides/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nikstoyanov.me/slides/example-slides/</guid>
      <description>

&lt;h1 id=&#34;welcome-to-slides&#34;&gt;Welcome to Slides&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://sourcethemes.com/academic/&#34; target=&#34;_blank&#34;&gt;Academic&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Efficiently write slides in Markdown&lt;/li&gt;
&lt;li&gt;3-in-1: Create, Present, and Publish your slides&lt;/li&gt;
&lt;li&gt;Supports speaker notes&lt;/li&gt;
&lt;li&gt;Mobile friendly slides&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;controls&#34;&gt;Controls&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Next: &lt;code&gt;Right Arrow&lt;/code&gt; or &lt;code&gt;Space&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Previous: &lt;code&gt;Left Arrow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start: &lt;code&gt;Home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Finish: &lt;code&gt;End&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Overview: &lt;code&gt;Esc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Speaker notes: &lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Fullscreen: &lt;code&gt;F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Zoom: &lt;code&gt;Alt + Click&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hakimel/reveal.js#pdf-export&#34; target=&#34;_blank&#34;&gt;PDF Export&lt;/a&gt;: &lt;code&gt;E&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;code-highlighting&#34;&gt;Code Highlighting&lt;/h2&gt;

&lt;p&gt;Inline code: &lt;code&gt;variable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Code block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;porridge = &amp;quot;blueberry&amp;quot;
if porridge == &amp;quot;blueberry&amp;quot;:
    print(&amp;quot;Eating...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;math&#34;&gt;Math&lt;/h2&gt;

&lt;p&gt;In-line math: $x + y = z$&lt;/p&gt;

&lt;p&gt;Block math:&lt;/p&gt;

&lt;p&gt;$$
f\left( x \right) = \;\frac{{2\left( {x + 4} \right)\left( {x - 4} \right)}}{{\left( {x + 4} \right)\left( {x + 1} \right)}}
$$&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;fragments&#34;&gt;Fragments&lt;/h2&gt;

&lt;p&gt;Make content appear incrementally&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{% fragment %}} One {{% /fragment %}}
{{% fragment %}} **Two** {{% /fragment %}}
{{% fragment %}} Three {{% /fragment %}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Press &lt;code&gt;Space&lt;/code&gt; to play!&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;fragment &#34; &gt;
  One
&lt;/span&gt;
&lt;span class=&#34;fragment &#34; &gt;
  &lt;strong&gt;Two&lt;/strong&gt;
&lt;/span&gt;
&lt;span class=&#34;fragment &#34; &gt;
  Three
&lt;/span&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;A fragment can accept two optional parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;: use a custom style (requires definition in custom CSS)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weight&lt;/code&gt;: sets the order in which a fragment appears&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;speaker-notes&#34;&gt;Speaker Notes&lt;/h2&gt;

&lt;p&gt;Add speaker notes to your presentation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;{{% speaker_note %}}
- Only the speaker can read these notes
- Press `S` key to view
{{% /speaker_note %}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Press the &lt;code&gt;S&lt;/code&gt; key to view the speaker notes!&lt;/p&gt;

&lt;aside class=&#34;notes&#34;&gt;
  &lt;ul&gt;
&lt;li&gt;Only the speaker can read these notes&lt;/li&gt;
&lt;li&gt;Press &lt;code&gt;S&lt;/code&gt; key to view&lt;/li&gt;
&lt;/ul&gt;

&lt;/aside&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;themes&#34;&gt;Themes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;black: Black background, white text, blue links (default)&lt;/li&gt;
&lt;li&gt;white: White background, black text, blue links&lt;/li&gt;
&lt;li&gt;league: Gray background, white text, blue links&lt;/li&gt;
&lt;li&gt;beige: Beige background, dark text, brown links&lt;/li&gt;
&lt;li&gt;sky: Blue background, thin dark text, blue links&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;night: Black background, thick white text, orange links&lt;/li&gt;
&lt;li&gt;serif: Cappuccino background, gray text, brown links&lt;/li&gt;
&lt;li&gt;simple: White background, black text, blue links&lt;/li&gt;
&lt;li&gt;solarized: Cream-colored background, dark green text, blue links&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;


&lt;section data-noprocess data-shortcode-slide
  
      
      data-background-image=&#34;/img/boards.jpg&#34;
  &gt;


&lt;h2 id=&#34;custom-slide&#34;&gt;Custom Slide&lt;/h2&gt;

&lt;p&gt;Customize the slide style and background&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;{{&amp;lt; slide background-image=&amp;quot;/img/boards.jpg&amp;quot; &amp;gt;}}
{{&amp;lt; slide background-color=&amp;quot;#0000FF&amp;quot; &amp;gt;}}
{{&amp;lt; slide class=&amp;quot;my-style&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;custom-css-example&#34;&gt;Custom CSS Example&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s make headers navy colored.&lt;/p&gt;

&lt;p&gt;Create &lt;code&gt;assets/css/reveal_custom.css&lt;/code&gt; with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.reveal section h1,
.reveal section h2,
.reveal section h3 {
  color: navy;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;questions&#34;&gt;Questions?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://discourse.gohugo.io&#34; target=&#34;_blank&#34;&gt;Ask&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://sourcethemes.com/academic/docs/&#34; target=&#34;_blank&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
