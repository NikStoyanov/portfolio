<!DOCTYPE html>
<html lang="en-US">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="http://localhost:1313/images/favicon.png" />
<title>Python and VTK scientific visualisation | Nikola Stoyanov</title>
<meta name="title" content="Python and VTK scientific visualisation" />
<meta name="description" content="Understanding adjoints Writing up my PhD is a pain mainly because of the detailed explanations that need to be provided. A technique I used throughout my project is to solve parameter optimization problems using the adjoint method. I learned the technique and used it, but never really got it until reading an amazing paper. This post represents my notes and Julia implementation of the work detailed in https://math.mit.edu/~stevenj/18.336/adjoint.pdf by Steven G." />
<meta name="keywords" content="Python,VTK,FEM,Scientific Computing," />


<meta property="og:url" content="http://localhost:1313/python-and-vtk-scientific-visualisation/">
  <meta property="og:site_name" content="Nikola Stoyanov">
  <meta property="og:title" content="Python and VTK scientific visualisation">
  <meta property="og:description" content="Understanding adjoints Writing up my PhD is a pain mainly because of the detailed explanations that need to be provided. A technique I used throughout my project is to solve parameter optimization problems using the adjoint method. I learned the technique and used it, but never really got it until reading an amazing paper. This post represents my notes and Julia implementation of the work detailed in https://math.mit.edu/~stevenj/18.336/adjoint.pdf by Steven G.">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2018-06-06T00:00:00+00:00">
    <meta property="article:modified_time" content="2018-06-06T00:00:00+00:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="VTK">
    <meta property="article:tag" content="FEM">
    <meta property="article:tag" content="Scientific Computing">
    <meta property="og:image" content="http://localhost:1313/images/share.png">




  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/images/share.png">
  <meta name="twitter:title" content="Python and VTK scientific visualisation">
  <meta name="twitter:description" content="Understanding adjoints Writing up my PhD is a pain mainly because of the detailed explanations that need to be provided. A technique I used throughout my project is to solve parameter optimization problems using the adjoint method. I learned the technique and used it, but never really got it until reading an amazing paper. This post represents my notes and Julia implementation of the work detailed in https://math.mit.edu/~stevenj/18.336/adjoint.pdf by Steven G.">




  <meta itemprop="name" content="Python and VTK scientific visualisation">
  <meta itemprop="description" content="Understanding adjoints Writing up my PhD is a pain mainly because of the detailed explanations that need to be provided. A technique I used throughout my project is to solve parameter optimization problems using the adjoint method. I learned the technique and used it, but never really got it until reading an amazing paper. This post represents my notes and Julia implementation of the work detailed in https://math.mit.edu/~stevenj/18.336/adjoint.pdf by Steven G.">
  <meta itemprop="datePublished" content="2018-06-06T00:00:00+00:00">
  <meta itemprop="dateModified" content="2018-06-06T00:00:00+00:00">
  <meta itemprop="wordCount" content="1541">
  <meta itemprop="image" content="http://localhost:1313/images/share.png">
  <meta itemprop="keywords" content="Python,VTK,FEM,Scientific Computing">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>
<style>
    body {
      font-family: Verdana, sans-serif;
      margin: auto;
      padding: 20px;
      max-width: 720px;
      text-align: left;
      background-color: #fff;
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: #ffffff;
    }
  
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #000000;
    }
  
    a {
      color: #3273dc;
       
    }
  
    .title {
      text-decoration: none;
      border: 0;
    }
  
    .title span {
      font-weight: 400;
    }
  
    nav a {
      margin-right: 10px;
    }
  
    textarea {
      width: 100%;
      font-size: 16px;
    }
  
    input {
      font-size: 16px;
    }
  
    content {
      line-height: 1.6;
    }
  
    table {
      width: 100%;
    }
  
    img {
      max-width: 100%;
    }
  
    code {
      padding: 2px 5px;
      background-color: #9c9c9c;
    }
  
    pre code {
      color: #222;
      display: block;
      padding: 20px;
      white-space: pre-wrap;
      font-size: 14px;
      overflow-x: auto;
    }
  
    div.highlight pre {
      background-color: initial;
      color: initial;
    }
  
    div.highlight code {
      background-color: unset;
      color: unset;
    }
  
    blockquote {
      border-left: 1px solid #999;
      color: #222;
      padding-left: 20px;
      font-style: italic;
    }
  
    footer {
      padding: 25px;
      text-align: center;
    }
  
    .helptext {
      color: #777;
      font-size: small;
    }
  
    .errorlist {
      color: #eba613;
      font-size: small;
    }
  
     
    ul.blog-posts {
      list-style-type: none;
      padding: unset;
    }
  
    ul.blog-posts li {
      display: flex;
    }
  
    ul.blog-posts li span {
      flex: 0 0 130px;
    }
  
    ul.blog-posts li a:visited {
      color: #8b6fcb;
    }
  
    @media (prefers-color-scheme: dark) {
      body {
        background-color: #ffffff;
        color: #000000;
      }
  
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      strong,
      b {
        color: #000000;
      }
  
      a {
        color: #8cc2dd;
      }
  
      code {
        background-color: #777;
      }
  
      pre code {
        color: #ddd;
      }
  
      blockquote {
        color: #ccc;
      }
  
      textarea,
      input {
        background-color: #252525;
        color: #ddd;
      }
  
      .helptext {
        color: #aaa;
      }
    }
  
  </style>
  
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
	  MathJax = {
		      tex: {
			            displayMath: [['\\[', '\\]'], ['$$', '$$']],  
			            inlineMath: [['\\(', '\\)'], ['$', '$']]      
			          },
		      loader:{
			            load: ['ui/safe']
			          },
		    };
</script>

  
</head>

<body>
  <header><a href="/" class="title">
  <h2>Nikola Stoyanov</h2>
</a>
<nav><a href="/">Home</a>

<a href="/bear/">Bear</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>Python and VTK scientific visualisation</h1>
<p>
  <i>
    <time datetime='2018-06-06' pubdate>
      06 Jun, 2018
    </time>
  </i>
</p>

<content>
  <h1 id="understanding-adjoints">Understanding adjoints</h1>
<p>Writing up my PhD is a pain mainly because of the detailed explanations that need to be provided. A technique I used throughout my project is to solve parameter optimization problems using the adjoint method. I learned the technique and used it, but never really <em>got</em> it until reading an amazing paper. This post represents my notes and Julia implementation of the work detailed in <a href="https://math.mit.edu/~stevenj/18.336/adjoint.pdf">https://math.mit.edu/~stevenj/18.336/adjoint.pdf</a> by Steven G. Johnson which is by far the best description I have read on Adjoint methods. I am really grateful that I typed up these notes some time ago which makes my writing life easier&hellip; I hope they help someone to implement similar problems in Julia.</p>
<h2 id="problem">Problem</h2>
<p>This work implements the solution to the optimization problem for the Schrödinger eigenequation described in <a href="https://math.mit.edu/~stevenj/18.336/adjoint.pdf">https://math.mit.edu/~stevenj/18.336/adjoint.pdf</a> by Steven G. Johnson.</p>
<h2 id="boilerplate">Boilerplate</h2>
<p>Let&rsquo;s setup the Julia environment. Here I will use the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> to solve the optimization problem and <a href="https://github.com/JuliaMath/IterativeSolvers.jl">IterativeSolvers.jl</a> which provides the conjugate gradient method to solve the matrix equations.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Pkg; Pkg<span style="color:#f92672">.</span>activate(<span style="color:#e6db74">&#34;.&#34;</span>)
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>Activating environment at `~/git/Personal_Website/content/post/2020-06-14-adjoints/Project.toml`
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Optim, Plots, LineSearches, SparseArrays, LinearAlgebra, IterativeSolvers
</span></span></code></pre></div><h2 id="the-adjoint-method">The Adjoint Method</h2>
<p>I recommend you read Steven G. Johnson&rsquo;s <a href="https://math.mit.edu/~stevenj/18.336/adjoint.pdf">paper</a>. The descriptions here are taken from that paper and summarized.</p>
<p>Given a set of equations M parametrized by a parameter P we optimize a function $g(x, p)$ on some space $x$. For optimizations we need the gradient $\frac{dg}{dp}$. The adjoint method rewrites the equation such that the we get a constant cost, it does not depend on the size of $P$ which is great if the dimension of the parameter space is large.</p>
<p>The change in the equation is shown next. Given $Ax=b$ with $A$ and $b$ parametrized by $P$:</p>
$$
\begin{equation}
\frac{dg}{dp} = g_p + g_x x_p
\end{equation}
$$<p>Where $x$ is $MxM$ with $g_p$ being a Jacobian of size $1xP$, $g_x$ being a Jacobian on size $1xM$, $x_p$ of size $MxP$. The difficulty comes from plugging in $x_p$.</p>
<p>To get $x_p$ we differentiate $Ax=b$ by $p_i$ for each parameter to get:</p>
$$
\begin{equation}
x_{pi} = A^{-1} (b_{pi} - A_{pi}x)
\end{equation}
$$<p>Plugging Equation 2 in Equation 1 we get:</p>
$$
\begin{equation}
g_x x_p = g_x A^{-1} (b_p - A_p x) = [g_x A^{-1}] (b_p - A_p x)
\end {equation}
$$<p>With the terms $g_x A^{-1}$ of size $1xM$ and $b_p - A_p x$ of size $MxP$. The difficulty being is that the computational cost is $\mathcal{O}(M^2P)$.</p>
<p>To make the problem easier we can rearrange the equation. If we multiply by $\lambda^T = g_x A^{-1}$ and from Equation 1 and Equation 2 we get:</p>
$$
\begin{equation}
\frac{dg}{dp} = g_p - \lambda^T (A_p x - b_p)
\end{equation}
$$<p>Where the multiplication now gives a tight bound $\Theta(MP)$.</p>
<h2 id="eigenequation">Eigenequation</h2>
<p>The equation for the problem in the paper is an eigenequation so we need to also follow the section which derives this case. Equations of this type are given by:</p>
$$
\begin{equation}
Ax = \alpha x
\end{equation}
$$<p>In block form we get:</p>
$$
\begin{equation}
\hat{x} = \begin{bmatrix} x \\ \alpha \end{bmatrix}
\end{equation}
$$<p>And for $f = Ax - \alpha x$:</p>
$$
\begin{equation}
\hat{f} = \begin{bmatrix} f \\ x^T x - 1 \end{bmatrix}
\end{equation}
$$<p>Using the same substitution for $\lambda$ we get:</p>
$$
\begin{equation}
\hat{\lambda} = \begin{bmatrix} \lambda \\ \beta \end{bmatrix}
\end{equation}
$$<p>Putting this together:</p>
$$
\begin{equation}
(A - \alpha) \lambda = g_x^T - 2\beta x
\end{equation}
$$$$
\begin{equation}
-x^T \lambda = g_a
\end{equation}
$$<h2 id="schrödinger-eigenequation">Schrödinger eigenequation</h2>
<p>The Schrödinger eigenequation is given by:</p>
$$
\begin{equation}
\left(-\frac{d^2}{dx^2} + V(x)\right) \psi(x) = E\psi(x)
\end{equation}
$$<p>With periodic boundary conditions $\psi(x+2) = \psi(x)$ over a domain $x \in [-1, 1]$.</p>
<p>In direct solving we are given $V(x)$ and solve for $\psi$ and $E$, in parameter optimization (inverse) we are looking for $V(x)$ that minimizes some cost. In this case the cost is:</p>
$$
\begin{equation}
g = \int_{-1}^{1} |\psi(x) - \psi_0 (x)|^2 dx
\end{equation}
$$<p>To solve the optimization problem we will:</p>
<ul>
<li>use finite difference method with central differencing to discretise the domain</li>
<li>normalize $\psi$ to $\psi \psi^T = 1$</li>
<li>project to $P = 1 - \psi \psi^T$</li>
<li>solve the adjoint $\frac{dg}{dV} = \lambda \psi$</li>
<li>solve $Ax = b$ for the smallest eigenvalue using Arnoldi iterations</li>
<li>optimize $g(\psi, V) = (\psi - \psi_0)^T (\psi - \psi_0) \Delta x$ using the Conjugate Gradient method</li>
<li>update the prediction $V(x)$ using the least-squares error against precalculated target data</li>
</ul>
<p>In other cases the precalculated target data can come from experimental measurements, recorded data etc.</p>
<h2 id="implementation">Implementation</h2>
<p>We setup the domain and the finite difference discretisation.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.02</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> x <span style="color:#f92672">=</span> [i <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>m <span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> N <span style="color:#f92672">=</span> length(x)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> dx <span style="color:#f92672">=</span> x[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> x[<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>0.020000000000000018
</code></pre>
<!-- raw HTML omitted -->
<p>We pick a function to generate the target data. This will later be used to compute the cost function and in inverse problems this is not known i.e. we are trying to backcalculate it. In my case such data comes from physical tests using thermocouples (very different than the example here but it can be solved with the same approach).</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#75715e"># Target solution, normalize and pick sign.</span>
</span></span><span style="display:flex;"><span>Ψ0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">.+</span> sin<span style="color:#f92672">.</span>(π <span style="color:#f92672">.*</span> x <span style="color:#f92672">.+</span> cos<span style="color:#f92672">.</span>(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> π <span style="color:#f92672">.*</span> x))
</span></span><span style="display:flex;"><span>Ψ0 <span style="color:#f92672">=</span> Ψ0 <span style="color:#f92672">/</span> sqrt(transpose(Ψ0) <span style="color:#f92672">*</span> Ψ0)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(sum(Ψ0) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    Ψ0 <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>Ψ0
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>In real problems we might be able to set prior knowledge about the problem but here we are just going to kick-start from an initial guess at $0$.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> V0 <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0.0</span> <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>m <span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>];
</span></span></code></pre></div><p>Discretise the space using center-difference scheme and set the periodic boundary conditions.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>Mesh <span style="color:#f92672">=</span> spdiagm(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> [<span style="color:#ae81ff">1.0</span> <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>               <span style="color:#ae81ff">0</span> <span style="color:#f92672">=&gt;</span> [<span style="color:#ae81ff">2.0</span> <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>N],
</span></span><span style="display:flex;"><span>               <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> [<span style="color:#ae81ff">1.0</span> <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Periodic boundary conditions.</span>
</span></span><span style="display:flex;"><span>Mesh[<span style="color:#ae81ff">1</span>, N] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>Mesh[N, <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Build mesh.</span>
</span></span><span style="display:flex;"><span>Mesh <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>Mesh <span style="color:#f92672">/</span> dx<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span>;
</span></span></code></pre></div><p>Next we need to setup the optimization problem. For this we need to pass the parameters which we setup above and create a data structure to store the current calculation state.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#75715e"># Build constants.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> p <span style="color:#f92672">=</span> [N, dx, Ψ0, Mesh]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mutable struct</span> <span style="color:#66d9ef">Schrodinger</span>{<span style="color:#66d9ef">T1</span>, <span style="color:#66d9ef">T2</span>, <span style="color:#66d9ef">T3</span>}
</span></span><span style="display:flex;"><span>    A<span style="color:#f92672">::</span><span style="color:#66d9ef">T1</span>
</span></span><span style="display:flex;"><span>    E<span style="color:#f92672">::</span><span style="color:#66d9ef">T2</span>
</span></span><span style="display:flex;"><span>    Ψ<span style="color:#f92672">::</span><span style="color:#66d9ef">T3</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>schr <span style="color:#f92672">=</span> Schrodinger(Mesh, <span style="color:#ae81ff">0.0</span>, zeros(N));
</span></span></code></pre></div><p>The finite difference disretisation with an initial guess allows us to solve $Ax=b$ using Arnoldi iterations (Conjugate gradient) and computing the cost function as the least squares error between the generated target data and predictions form the the current solution state.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> schrodinger_fd(V, schr, p)
</span></span><span style="display:flex;"><span>    N, _, Ψ0, Mesh <span style="color:#f92672">=</span> p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    A <span style="color:#f92672">=</span> Mesh <span style="color:#f92672">+</span> Diagonal(V)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Smallest values.</span>
</span></span><span style="display:flex;"><span>    E <span style="color:#f92672">=</span> eigvals(<span style="color:#66d9ef">Matrix</span>(A))[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    Ψ <span style="color:#f92672">=</span> eigvecs(<span style="color:#66d9ef">Matrix</span>(A))[<span style="color:#f92672">:</span>, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Pick sign.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(sum(Ψ) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        Ψ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>Ψ
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    schr<span style="color:#f92672">.</span>A <span style="color:#f92672">=</span> A
</span></span><span style="display:flex;"><span>    schr<span style="color:#f92672">.</span>E <span style="color:#f92672">=</span> E
</span></span><span style="display:flex;"><span>    schr<span style="color:#f92672">.</span>Ψ <span style="color:#f92672">=</span> Ψ
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Least-squares error.</span>
</span></span><span style="display:flex;"><span>    err <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>N
</span></span><span style="display:flex;"><span>        err <span style="color:#f92672">+=</span> (Ψ[i] <span style="color:#f92672">-</span> Ψ0[i])<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> err
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>schrodinger_fd (generic function with 1 method)
</code></pre>
<!-- raw HTML omitted -->
<p>Finally, we add the derived equations for the adjoint and pass the solution state to calculate the gradient. The adjoint equations are solved with the Conjugate gradient method.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> schrodinger_fd_adj(gp, V, schr, p)
</span></span><span style="display:flex;"><span>    N, dx, Ψ0, _ <span style="color:#f92672">=</span> p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    A <span style="color:#f92672">=</span> schr<span style="color:#f92672">.</span>A
</span></span><span style="display:flex;"><span>    E <span style="color:#f92672">=</span> schr<span style="color:#f92672">.</span>E
</span></span><span style="display:flex;"><span>    Ψ <span style="color:#f92672">=</span> schr<span style="color:#f92672">.</span>Ψ
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    gΨ <span style="color:#f92672">=</span> Ψ <span style="color:#f92672">-</span> Ψ0
</span></span><span style="display:flex;"><span>    g <span style="color:#f92672">=</span> transpose(gΨ) <span style="color:#f92672">*</span> gΨ <span style="color:#f92672">*</span> dx
</span></span><span style="display:flex;"><span>    gΨ <span style="color:#f92672">=</span> gΨ <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> dx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    P(Ψx) <span style="color:#f92672">=</span> Ψx <span style="color:#f92672">-</span> Ψ <span style="color:#f92672">*</span> (transpose(Ψ) <span style="color:#f92672">*</span> Ψx)
</span></span><span style="display:flex;"><span>    λ <span style="color:#f92672">=</span> cg(A <span style="color:#f92672">-</span> Diagonal([E <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>N]), P(gΨ))
</span></span><span style="display:flex;"><span>    λ <span style="color:#f92672">=</span> P(λ)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    copyto!(gp, <span style="color:#f92672">-</span>real(conj(λ) <span style="color:#f92672">.*</span> Ψ))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>schrodinger_fd_adj (generic function with 1 method)
</code></pre>
<!-- raw HTML omitted -->
<p>We can now fill in the initial state with the guess for $V_0$.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>schrodinger_fd(V0, schr, p)
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>0.36358289201172456
</code></pre>
<!-- raw HTML omitted -->
<p>After the initial state we can pass with to <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> and optimize using the Conjugate gradient method and the <a href="https://github.com/JuliaNLSolvers/LineSearches.jl">Nocedal and Wright line search</a>.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>res<span style="color:#f92672">=</span> optimize(V0 <span style="color:#f92672">-&gt;</span> schrodinger_fd(V0, schr, p),
</span></span><span style="display:flex;"><span>              (gp, V) <span style="color:#f92672">-&gt;</span> schrodinger_fd_adj(gp, V, schr, p),
</span></span><span style="display:flex;"><span>              V0,
</span></span><span style="display:flex;"><span>              ConjugateGradient(;alphaguess <span style="color:#f92672">=</span> LineSearches<span style="color:#f92672">.</span>InitialStatic(),
</span></span><span style="display:flex;"><span>                                linesearch <span style="color:#f92672">=</span> LineSearches<span style="color:#f92672">.</span>StrongWolfe()),
</span></span><span style="display:flex;"><span>              Optim<span style="color:#f92672">.</span>Options(iterations <span style="color:#f92672">=</span> <span style="color:#ae81ff">1500</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>show(res)
</span></span><span style="display:flex;"><span>V <span style="color:#f92672">=</span> Optim<span style="color:#f92672">.</span>minimizer(res)
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code> * Status: failure (reached maximum number of iterations)

 * Candidate solution
    Minimizer: [-6.97e+01, -6.31e+01, -5.21e+01,  ...]
    Minimum:   1.073967e-02

 * Found with
    Algorithm:     Conjugate Gradient
    Initial Point: [0.00e+00, 0.00e+00, 0.00e+00,  ...]

 * Convergence measures
    |x - x'|               = 2.25e-02 ≰ 0.0e+00
    |x - x'|/|x'|          = 2.76e-04 ≰ 0.0e+00
    |f(x) - f(x')|         = 5.17e-06 ≰ 0.0e+00
    |f(x) - f(x')|/|f(x')| = 4.81e-04 ≰ 0.0e+00
    |g(x)|                 = 2.50e-07 ≰ 1.0e-08

 * Work counters
    Seconds run:   205  (vs limit Inf)
    Iterations:    1500
    f(x) calls:    25492
    ∇f(x) calls:   25492
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>101-element Array{Float64,1}:
 -69.7179927132526  
 -63.069608186066425
 -52.087451574006884
 -37.36573473180763 
 -20.180400235224578
  -2.229225733813316
  14.749615511053337
  29.331853859440123
  40.62554608422707 
  48.3225249611126  
  52.61571536510694 
  54.042947983512384
  53.31503924672539 
   ⋮                
  17.178647984621353
   8.021381994966156
  -2.573762022324184
 -14.023136038593602
 -25.664072903254834
 -36.846554029251884
 -47.03051365926664 
 -55.83742898698404 
 -63.019981543247575
 -68.35860212436283 
 -71.54666184631233 
 -72.15224515470479 
</code></pre>
<!-- raw HTML omitted -->
<p>After the convergence criteria are met we can get the final state.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#75715e"># Calculate the Ψ for the optimized V.</span>
</span></span><span style="display:flex;"><span>schrodinger_fd(V, schr, p)
</span></span><span style="display:flex;"><span>Ψ <span style="color:#f92672">=</span> schr<span style="color:#f92672">.</span>Ψ
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>101-element Array{Float64,1}:
 0.14833164726134337 
 0.13919394825641024 
 0.1278699952817301  
 0.11509936367379768 
 0.10170432021101757 
 0.0884566618539783  
 0.07597235110988376 
 0.06465962208332779 
 0.05472117218785397 
 0.04619297069858297 
 0.03899745133110734 
 0.032993990421552606
 0.028017912623404584
 ⋮                   
 0.09614588450255365 
 0.10240636155599434 
 0.10997045784342774 
 0.11846840215967322 
 0.1274298017992534  
 0.13629635337111087 
 0.1444518047974951  
 0.15126517003159562 
 0.15614027501154157 
 0.1585660575136774  
 0.15816585545769815 
 0.1547451044185629  
</code></pre>
<!-- raw HTML omitted -->
<p>Finally, we create a plot and see how well we did.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span>scatter(x, Ψ, label <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Psi_i&#34;</span>,
</span></span><span style="display:flex;"><span>        markersize <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>        markerstrokecolor <span style="color:#f92672">=</span> <span style="color:#e6db74">:blue</span>,
</span></span><span style="display:flex;"><span>        markercolor <span style="color:#f92672">=</span> <span style="color:#e6db74">:white</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plot!(x, Ψ0, label <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Psi_0&#34;</span>,
</span></span><span style="display:flex;"><span>      color <span style="color:#f92672">=</span> <span style="color:#e6db74">:red</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plot!(x, V <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000</span>, label <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;V/1000&#34;</span>,
</span></span><span style="display:flex;"><span>      linestyle <span style="color:#f92672">=</span> <span style="color:#e6db74">:dash</span>,
</span></span><span style="display:flex;"><span>      color <span style="color:#f92672">=</span> <span style="color:#e6db74">:black</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plot!(xlims <span style="color:#f92672">=</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>      xticks <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0.2</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>      ylims <span style="color:#f92672">=</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">0.15</span>, <span style="color:#ae81ff">0.2</span>),
</span></span><span style="display:flex;"><span>      yticks <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.15</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0.05</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0.2</span>,
</span></span><span style="display:flex;"><span>      grid <span style="color:#f92672">=</span> false,
</span></span><span style="display:flex;"><span>      legend <span style="color:#f92672">=</span> <span style="color:#e6db74">:bottomleft</span>,
</span></span><span style="display:flex;"><span>      fmt <span style="color:#f92672">=</span> <span style="color:#e6db74">:svg</span>,
</span></span><span style="display:flex;"><span>      framestyle <span style="color:#f92672">=</span> <span style="color:#e6db74">:box</span>)
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><img src="/images/2020-06-14-adjoints/adjoints_64_0.svg" alt="svg"></p>
<!-- raw HTML omitted -->
<p>That&rsquo;s pretty good, considering it only took two-three minutes on my Thinkpad laptop to optimize 100 dimensional case and the function is not trivial!</p>

</content>
<p>
  
  <a href="http://localhost:1313/blog/python/">#Python</a>
  
  <a href="http://localhost:1313/blog/vtk/">#VTK</a>
  
  <a href="http://localhost:1313/blog/fem/">#FEM</a>
  
  <a href="http://localhost:1313/blog/scientific-computing/">#Scientific Computing</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
