[{"authors":["admin"],"categories":null,"content":"Hello! My name is Nikola Stoyanov and I am a materials science PhD student at the University of Manchester.\nMy current research activities include the numerical element modeling of the structural and thermal resistance of shell elements using cohesive fracture models during low and high temperature exporures. I am also trying to figure out a way to make predictions without excessive computations and access to expensive software - analytical solutions are very difficult, but maybe new emerging methods can hold an answer.\n","date":1550351215,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1550351215,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://nikstoyanov.me/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"Hello! My name is Nikola Stoyanov and I am a materials science PhD student at the University of Manchester.\nMy current research activities include the numerical element modeling of the structural and thermal resistance of shell elements using cohesive fracture models during low and high temperature exporures. I am also trying to figure out a way to make predictions without excessive computations and access to expensive software - analytical solutions are very difficult, but maybe new emerging methods can hold an answer.","tags":null,"title":"Nikola Stoyanov","type":"author"},{"authors":null,"categories":null,"content":"This feature can be used for publishing content such as:\n Project or software documentation Online courses Tutorials  The parent folder may be renamed, for example, to docs for project documentation or course for creating an online course.\nTo disable this feature, either delete the parent folder, or set draft = true in the front matter of all its pages.\nAfter renaming or deleting the parent folder, you may wish to update any [[menu.main]] menu links to it in the config.toml.\n","date":1536447600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1550333982,"objectID":"c3224f3a64174f08aaf31e1f1d16ffd3","permalink":"https://nikstoyanov.me/tutorial/","publishdate":"2018-09-09T00:00:00+01:00","relpermalink":"/tutorial/","section":"tutorial","summary":"This feature can be used for publishing content such as:\n Project or software documentation Online courses Tutorials  The parent folder may be renamed, for example, to docs for project documentation or course for creating an online course.\nTo disable this feature, either delete the parent folder, or set draft = true in the front matter of all its pages.\nAfter renaming or deleting the parent folder, you may wish to update any [[menu.","tags":null,"title":"Overview","type":"docs"},{"authors":["Nikola Stoyanov"],"categories":["Optimization","Inverse Problems"],"content":"Recently I had to reconstruct a solution for the thermal boundary between boiling cryogenic liquid and a steel plate. The temperature of the cryogenic-steel boundary is extremely difficult to measure experimentally since the mere presence of the thermocouples would affect the nucleation of bubbles which in turn affect the heat extraction. Also modeling the boiling phenomena is a great computational challenge which is too great of a topic to undertake for this problem. An easier way would be to perform an experiment and measure the temperature at the bottom of the plate. We can then build a direct numerical model which predicts those temperatures and reconstruct the exposure by iterating the initial guess. In this post I will present the Tikhonov regularization method which is used to solve the ill-posed problem.\nDirect problem In theory inversing the heat equation sounds great, however, the direct numerical implementation would inevitable lead to an ill-posed problem which we cannot solve. To illustrate lets consider the one dimensional heat transfer problem. We want to reconstruct temperatures $T(x, t=t_{0})$ in the past, based on present-day measurements $T(x, t=t_{1})$. In this model we consider the diffusion problem only without and external heat generation or internal heat generation. The heat equation is then given by the parabolic partial differential equation below.\n\\[ \\frac{\\partial T}{\\partial t} = u \\frac{\\partial^{2} T}{\\partial x^{2}} \\]\nWhere $T$ is temperature, $t$ is time, $u$ is a constant to represent the material properties and $x$ is the length dimension. The equation represents the balance of energy between the capacitive term $\\partial T/\\partial t$ and the diffusion $\\partial T^{2}/\\partial x^{2}$ i.e. the heat transfered through diffusion is responsible for the temperature change.\nLets impose a periodic boundary condition.\n\\[ T(x+L, t) = T(x, t) \\]\nThe heat equation can be solved by a simple finite difference explicit scheme as below.\n\\[ \\frac{\\Delta T_{n}}{\\Delta t} = u \\frac{T_{n-1} - T_{n}}{\\Delta x^{2}} - u \\frac{T_{n} - T_{n+1}}{\\Delta x^{2}} \\]\nThe equation can be vectorized and we can incorporate the boundary condition in the matrix L to handle the internal and external nodes.\n\\[ \\frac{\\Delta T}{\\Delta t} = u \\frac{L T}{\\Delta x^{2}} \\]\nThe linear combination of the equations can then be rewritten by combining the boundary condition, $L$ and the material properties, $u$ as below.\n\\[ T_{t+1} = A T_{t} \\]\nExplicit schemes have issues with numerical stability and require limiting values of the mesh size, $\\Delta x$ and time step, $t$. For those interested, the reason is the we are solving a direct system of equations and we need to allow enough time, $(t)$ for the information to propagate from cell to cell, $(\\Delta x)$. The critical relationship is known as the Courant–Friedrichs–Lewy (CFL) condition and we would need to check that it is satisfied.\nIf we chose the values of the constants the above equation can be solved directly. In fact this is known as the direct problem.\nThe finite difference method can be conveniently implemented using a Toeplitz matrix to approximate the derivatives. The matrix is build using constant value descending diagonals from left to right. The matrix can be represented as\n\\[ \\begin{bmatrix} a \u0026 b \u0026 c \u0026 d \\\\ d \u0026 a \u0026 b \u0026 c \\\\ c \u0026 d \u0026 a \u0026 b \\\\ d \u0026 c \u0026 b \u0026 a \\\\ \\end{bmatrix} \\]\nOur simple discretization scheme is using forward difference for the time and central difference for the space, so lets implement it.\nWe will use numpy and scipy for our work.\nIn\u0026nbsp;[1]: import scipy.linalg import numpy as np  The domain is discretised using $n=15$ elements and the time step is $t=2\\times 10^{1}$. The Tikhonov regularization temr is given by $w=1\\times 10^{-2}$.\nIn\u0026nbsp;[2]: n = 40 t = 1e1  We can then apply the boundary condition using the Toeplitz matrix.\nIn\u0026nbsp;[3]: A = np.zeros((1, n)) A[0, 0] = -1 A[0, 1] = 0.5 A[0, -1] = 0.5 L = scipy.linalg.toeplitz(A)  Let us check the CFL condition for our chosen constants.\nIn\u0026nbsp;[4]: t/n \u0026lt; 1  Out[4]: True  \nall seems okay, we can then calculate the matrix $A$.\nIn\u0026nbsp;[5]: A = scipy.linalg.fractional_matrix_power(np.eye(n) + L, t)  The initial condition is then set to provide us with a problem that is interesting to recover.\nIn\u0026nbsp;[6]: x = np.arange(0, n) Tt = np.sin(3*np.pi * x / n)  We can then calculate the direct problem $T_{t+1} = A T_{t}$.\nIn\u0026nbsp;[7]: Tfwd = np.dot(A, Tt) Tfwd  Out[7]: array([ 0.48258534, 0.52670091, 0.54171091, 0.62253495, 0.66895761, 0.73312732, 0.75678431, 0.75913893, 0.71954341, 0.64474529, 0.53431844, 0.39482101, 0.23350572, 0.05928686, -0.1182082 , -0.28917105, -0.44415427, -0.57459345, -0.67328051, -0.73476198, -0.75564038, -0.73476198, -0.67328051, -0.57459345, -0.44415427, -0.28917105, -0.1182082 , 0.05928686, 0.23350572, 0.39482101, 0.53431844, 0.64474529, 0.71954341, 0.75913893, 0.75678431, 0.73312732, 0.66895761, 0.62253495, 0.54171091, 0.52670091])  \nThe solution, $T_{t+1}$ is then visualized and it can be seen that, $T_{t}$ has diffused towards the 0 temperature condition.\nIn\u0026nbsp;[8]: import matplotlib.pyplot as plt from IPython.display import set_matplotlib_formats %matplotlib inline set_matplotlib_formats('svg') plt.plot(x, Tt, label='$T_{t}$') plt.plot(x, Tfwd, label='$T_{t+1}$') plt.legend() plt.show()  Out[8]: \n\nInverse problem The interesting question then becomes: what if we already know the values of $T_{t+1}$ and want to find what $T_{t}$ was? Such a case can be that we have measured the temperature and we are trying to figure out what the temperature used to be before. Naively we can try to inverse the matrix $A$.\n\\[ T_{t} = A^{-1} T_{t+1} \\]\nIn\u0026nbsp;[9]: Tinv = np.dot(np.linalg.inv(A), Tfwd) Tinv  Out[9]: array([ 6.800e+01, -2.000e+00, -3.560e+02, -4.000e+00, 9.160e+02, 3.000e+01, -1.632e+03, -2.200e+01, 2.192e+03, -2.400e+01, -2.288e+03, 9.600e+01, 1.920e+03, -1.880e+02, -1.304e+03, 2.540e+02, 7.400e+02, -2.680e+02, -3.680e+02, 2.120e+02, 1.680e+02, -1.280e+02, -7.200e+01, 5.200e+01, 1.600e+01, -1.600e+01, 8.000e+00, -2.000e+00, -1.600e+01, 0.000e+00, 4.000e+00, 0.000e+00, -4.000e+00, 6.000e+00, -1.200e+01, -2.000e+00, 8.000e+00, 4.000e+00, -8.000e+00, 0.000e+00])  \nWe have obtained the inverse matrix. Lets check if we can recover the identity matrix, $I$, even though in this case a visual inspection tells me that something is not right. We are expecting to obtain the equation below.\n\\[ A^{-1}A = I \\]\nWe will see that for our case we would not be able to recover it which means that our inversion did not work satisfactory. In other words during the inversion the condition number of the matrix $A$ is so large that the rounding errors are amplified to the point where the errors dominate the solution.\nIn\u0026nbsp;[10]: np.allclose(np.dot(A, np.linalg.inv(A)), np.eye(n))  Out[10]: False  \nAs expected our matrix is ill-conditioned and direct inversion did not provide satisfactory results. Lets check the condition number.\nIn\u0026nbsp;[11]: np.linalg.cond(A)  Out[11]: 3.249636913192119e+16  \nThis is a huge number! The problem arises if the condition number is greater than the machine precision.\nIn\u0026nbsp;[12]: np.linalg.cond(A) \u0026gt; np.finfo(A.dtype).eps  Out[12]: True  \nIt seems that this is a wrong approach to use. The condition number is orders of magnitude larger and the errors speak for themselves. In the plot below we are expecting $T_{t}$ and $T_{inv}$ to match.\nIn\u0026nbsp;[13]: plt.plot(x, Tt, label='$T_{t}$') plt.plot(x, Tinv, label='$T_{inv}$') plt.legend() plt.show()  Out[13]: \n\nWe have clearly not been able to recover $T_{t}$ from the naive method of inversion.\nTikhonov Regularization Tikhonov regularization, with small modification known as Ridge regression in statistics or Weight decay in machine learning can solve the problem by imposing a penalty term $\\lambda$. Such problems can be formulated as\n\\[ \\begin{align} \\text{Minimize } \u0026 ||A T_{t} - T_{fwd}||_{2}^{2} + \\lambda ||LT_{t}||^{2}_{2} \\\\ \\text{Subject to } \u0026 A \\geq 0 \\end{align} \\]\nThis can be done using a linear least squares solver by $lstsq(B, C)$ where we can implement the Tikhonov regularization in the arguments. For reference, the least squares solver expects problems of the type below.\n\\[ \\text{Minimize } ||AT_{t} - T_{fwd}||_{2}^{2} \\]\nThe arguments been to be modified as such:\n\\[ B = \\begin{bmatrix} A\\\\ \\lambda L \\end{bmatrix} \\]\nAnd\n\\[ C = \\begin{bmatrix} T_{fwd}\\\\ L \\times 0\\\\ \\end{bmatrix} \\]\nWe also need a function to calculate the $R^{2}$ of the fit.\nIn\u0026nbsp;[22]: from scipy.stats import linregress def rsqr(x, y): slope, intercept, r_value, p_value, std_err = linregress(x, y) return r_value**2  The problem can then be solved.\nIn\u0026nbsp;[27]: classifiers = [100, 50, 15, 5, 1, 0.1] r_squared = [] C = np.concatenate([Tfwd, np.zeros(n)]) fig, ax = plt.subplots(2, 1, figsize=(7.5, 10)) for tikhonov in classifiers: B = np.concatenate([A, tikhonov*L]) T_lstqs = np.linalg.lstsq(B, C, rcond=None) ax[0].scatter(x, T_lstqs[0], label=\u0026quot;$\\lambda=$\u0026quot; + str(tikhonov)) r_squared.append(rsqr(Tt, T_lstqs[0])) ax[1].scatter(tikhonov, r_squared[-1], label=\u0026quot;$\\lambda=$\u0026quot; + str(tikhonov)) ax[0].plot(x, Tt, label='$T_{t}$', linewidth=2.5, color='black') ax[0].legend() ax[1].plot(classifiers, r_squared) ax[1].legend() plt.show()  Out[27]: \n\nWe can see that the results converge towards $T_{t}$ as $\\lim_{\\lambda \\to 0} T(\\lambda)$.\nlstsq Solution For completeness I want to show that we can straight up use $lstsq$ to solve the problem without going in any detail about regularization. However, in doing this we don't learn anything new and we will see in further posts that Tikhonov regularization is indeed needed for solving the bigger optimization problem which is the temperature recovery through the thickness of the specimen to obtain the surface temperature.\nIn\u0026nbsp;[16]: Tls = np.linalg.lstsq(A, Tfwd, rcond=None)  In\u0026nbsp;[17]: plt.scatter(x, Tls[0], label='Tls') plt.plot(x, Tt, label='$T_{t}$') plt.legend() plt.show()  Out[17]: \n\nWhich gives a very good fit!\nIn\u0026nbsp;[18]: rsqr(Tt, Tls[0])  Out[18]: 0.9998417880466148  \nConclusion We have implemented Tikhonov regularization to solve an ill-conditioned inverse problem. Now we can recover temperatures from previous time steps by only using the current results. Stay tuned for the next posts where I will implement the above solution technique to recover temperatures on the exposed surface by readings from thermocouples located in the depth.\n","date":1545955200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550351215,"objectID":"2972708701cdf917219c41ebd265d257","permalink":"https://nikstoyanov.me/post/2018-12-29-regularization-illposed/","publishdate":"2018-12-28T00:00:00Z","relpermalink":"/post/2018-12-29-regularization-illposed/","section":"post","summary":"Implementing Tikhonov regularization (weight decay/ridge regression) in Python to solve ill-posed problems.","tags":["Python","Scipy","Numerical Analysis","Scientific Computing"],"title":"Regularization of ill-posed problems","type":"post"},{"authors":null,"categories":null,"content":" In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 \u0026hellip;\nTip 2 \u0026hellip;\n","date":1536447600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550333982,"objectID":"6a451186c775f5f0adb3a0416d0cb711","permalink":"https://nikstoyanov.me/tutorial/example/","publishdate":"2018-09-09T00:00:00+01:00","relpermalink":"/tutorial/example/","section":"tutorial","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 \u0026hellip;\nTip 2 \u0026hellip;","tags":null,"title":"Example Page","type":"docs"},{"authors":["Nikola Stoyanov"],"categories":["Visualization"],"content":"I recently rewatched a video from Arthur C. Clarke which is where I first saw what fractals are. I saw this video while I was in high school and having rewatched it now I wondered if I can generate the Mandelbrot set and explore some parts of it myself. I did a quick search online and I discovered that Jean Francois Puget had already done that and achieved great results. Learning from his work I decided to do some computational experiments.\nFor this post I will use the acceleration provided by numba as in the original post by Jean Francois Puget. In a further post he developed a parallel version of the code so you can check it out, but for my purposes now numba will be enough.\nFractals Fractals are abstract objects that are infinitely complicated and exhibit similar patterns at increasingly smaller scales. What this means is that we can keep zooming in the fractal until the original picture is bigger than the visible universe and still see patterns. For this post I want to explore the Mandelbrot set and produce the fractal from it. However, before delving in the Mandelbrot set we need to look at the more general picture.\nThe Mandelbrot set is made by iteration using the simple formula \\(z_{n+1} = z_n^2 + c\\) for different values of $c$ in the complex plane. Then we have two possible paths: the iteration will converge or diverge. Points on the complex plane $\\mathbb{C}$ for which $z_n$ is bounded form the Mandelbrot set. Points which are not bounded do not belong to the Mandelbrot set and to get artistic pictures are usually coloured based on how fast they change. Each point $c$ then specifies the geometric structure of the corresponding Julia set.\nJulia sets are formed by performing a repeated iteration of a holomorphic function and in this post we will investigate polynomial functions of the form $z_{n+1} = z_{n}^2 + c$. The set has an interesting property of chaotic behaviour which produces drastically different result from a small perturbation. The Julia set also has a complementary set known as the Fatou set which has the property that all values behave similarly under the repeated iteration. Now if a point $c$ is in the Mandelbrot set the Julia set is called connected, if it is not then it is known as Cantor/Fatou dust.\nWe can now visualise what we mean by the above by using some Python code and the Scipy library.\nMandelbrot Set The Mandelbrot set is generated using the iterative formula below.\n\\[z_{n+1} = z_{n}^{2} + c\\]\nTo get the set we start from $z_{0} = 0$ for a given $c$ coordinate. Expressing it mathematically, for a point to belong to the Mandelbrot set we need the limit to be $\\leq 2$. The precise reason is given below.\n\\[c \\in M \\iff \\lim_{n \\to \\infty} \\sup|z_{n+1}| \\leq 2\\]\nWhen I first saw the mathematical description I could not understand why was the number 2 written as the upper boundary to determine if a point belongs to the Mandelbrot set or not. I decided to dig further and I found the mathematical proof. I found the explanation in Alun Williams' website and you can read it there.\nLets define the function for the Mandelbrot set.\nIn\u0026nbsp;[1]: import numpy as np from numba import jit @jit def mandelbrot(c, maxiter): z = c for n in range(maxiter): if abs(z) \u0026gt; 2: return n z = z*z + c return 0  The holomorphic function can then be called to generate the Mandelbrot set. I will take this opportunity to generalise the set generation and plot functions so we can use them with the Julia set as well.\nIn\u0026nbsp;[2]: @jit def generate_set(set_function, xmin, xmax, ymin, ymax, width, height, maxiter): r1 = np.linspace(xmin, xmax, width) r2 = np.linspace(ymin, ymax, height) n3 = np.empty((width,height)) for i in range(width): for j in range(height): n3[i, j] = set_function(r1[i] + 1j * r2[j], maxiter) return (r1, r2, n3)  Having generated the set we need a way to visualise it. We can do this with Matplotlib. As states above the algorithm to display the fractals is explained here.\nIn\u0026nbsp;[3]: from matplotlib import pyplot as plt from matplotlib import colors from matplotlib import patches from IPython.display import set_matplotlib_formats %matplotlib inline set_matplotlib_formats('png') def generate_image(set_function, xmin, xmax, ymin, ymax, width=10, height=10, maxiter=256): dpi = 72 img_width = dpi * width img_height = dpi * height x,y,z = generate_set(set_function, xmin, xmax, ymin, ymax, img_width, img_height, maxiter) fig, ax = plt.subplots(figsize=(width, height), dpi=72) ticks = np.arange(0, img_width, 3*dpi) x_ticks = xmin + (xmax-xmin)*ticks/img_width plt.xticks(ticks, x_ticks) y_ticks = ymin + (ymax-ymin)*ticks/img_width plt.yticks(ticks, y_ticks) ax.imshow(z.T, origin='lower')  We can then visualise the Mandelbrot set.\nIn\u0026nbsp;[4]: generate_image(mandelbrot, -2.0, 0.5, -1.25, 1.25)  Out[4]: \n\nThe \u0026quot;main\u0026quot; part of the Mandelbrot is called the main cardioid and the set contains small copies of itself connected to the main cardioid. This continues and we get structures which resemble hairs, not surprisingly these features are called Mandelbrot hair.\nOther explorers have discovered interesting anchor points. For example lets set sail to $-0.761574-i0.0847596$ as shown on maps generated by Paul Bourke. We will centre at this point and zoom $\\times 10$ to start with. Note that the original generated image is of size $2.5\\times2.5$ and we need a function to generate the size of the image for the given zoom.\nIn\u0026nbsp;[5]: def zoom_image(xc, yc, size): x1 = xc - size x2 = xc + size y1 = yc - size y2 = yc + size return x1, x2, y1, y2  We can than choose our point of interest and zoom into it.\nIn\u0026nbsp;[6]: xc = -0.761574 yc = -0.0847596 size = 2.5 / 10 x1, x2, y1, y2 = zoom_image(xc, yc, size) generate_image(mandelbrot, x1, x2, y1, y2)  Out[6]: \n\nGreat, everything is looking fine. We can see the primary continental mu-atom and a mu-atom of period 2, if you want an explanation of the names go here. The place in the middle where all the interesting features occur is know as the seahorse valley and we are going to explore the southern part. Lets zoom $\\times 500$ and explore the seahorses.\nIn\u0026nbsp;[7]: size = 2.5 / 500 x1, x2, y1, y2 = zoom_image(xc, yc, size) generate_image(mandelbrot, x1, x2, y1, y2)  Out[7]: \n\nWe can see why mathematicians are referring to these patters as seahorses. Also notice that more patterns are starting to emerge as we go deeper in the set. Why stop now, $\\times 1000$ it is.\nIn\u0026nbsp;[8]: size = 2.5 / 1000 x1, x2, y1, y2 = zoom_image(xc, yc, size) generate_image(mandelbrot, x1, x2, y1, y2)  Out[8]: \n\nI will test the ability of our code to cope with even more decimals places and zoom to $\\times 15625$. We can then compare with the image obtained from Paul Bourke.\nIn\u0026nbsp;[9]: size = 2.5 / 15625 x1, x2, y1, y2 = zoom_image(xc, yc, size) generate_image(mandelbrot, x1, x2, y1, y2)  Out[9]: \n\nOkay, lets go wild and do a $5\\times10^6$ zoom.\nIn\u0026nbsp;[10]: size = 2.5 / (5 * (10**6)) x1, x2, y1, y2 = zoom_image(xc, yc, size) generate_image(mandelbrot, x1, x2, y1, y2)  Out[10]: \n\nWhoops, it seems that we have reached the limit of the colouring algorithm. This is an issue for another post, where I am planning to program the problem in C++ and use different generation and colouring algorithms.\nJulia Set To generate a Julia set we need a holomorphic function. In other words we need a continuously differentiable complex-valued function with one or more complex variable. Lets start with something random... the first thing that comes to mind.\n\\[f(z) = z^3 + c\\]\nThe iteration is then performed for:\n\\[z_{n+1} = z_{n}^{3} + c\\]\nWe can then get the points that tend to infinity, those that do not (Fatou set) and the boundary between them (Julia set) for a complex number $k$ if we set $c=k$ and start with $z_{0}$ as the coordinates of a point. Lets explore $c = -0.1 + i0.65$ which is in the Mandelbrot set and we would get a connected Julia set. The way I have implemented this is to define a holomorphic function with a given complex parameter $c$, the seemingly weird use of $c$ as an argument to define $z$ and then be redefined is just for convenience so I can use the same set generation function as for the Mandelbrot set.\nIn\u0026nbsp;[11]: @jit def holomorphic_julia(c, maxiter): z = c c = complex(-0.1, 0.65) for n in range(maxiter): if abs(z) \u0026gt; 10: return n z = z*z + c return 0  We can then show our results and we get a weird looking bulge.\nIn\u0026nbsp;[12]: generate_image(holomorphic_julia, -1.5, 1.5, -1.5, 1.5)  Out[12]: \n\nLets examine the fractal nature of this thing we have produced. We would focus in the middle of our bulge.\nIn\u0026nbsp;[13]: xc = 0.0 yc = 0.0 size = 3.0 / 10 x1, x2, y1, y2 = zoom_image(xc, yc, size) generate_image(holomorphic_julia, x1, x2, y1, y2)  Out[13]: \n\nWe can see that we have generated a fractal since zooming in reveals similar patterns of infinity complexity. We can also see the Julia set as the boundary between the Fatou sets.\nNow we can pick a point which is outside of the Mandelbrot set. Such a point is $c = -2.5 - i2.5$.\nIn\u0026nbsp;[14]: @jit def holomorphic_candor_dust(c, maxiter): z = c c = complex(-2.5, -2.5) for n in range(maxiter): if abs(z) \u0026gt; 10: return n z = z*z + c return 0 generate_image(holomorphic_candor_dust, -4.0, 4.0, -4.0, 4.0)  Out[14]: \n\nThis is known as Cantor/Fatou dust and the calculation oscillates between the points on the plot which is very different from the previous Julia set. As can be seen the resultant behaviour is very much dependent on whether $c$ is in the Mandelbrot set or not. We can also investigate different complex parameters. For example lets see a $c = -0.78 + 0.1i$ which is in the Mandelbrot set and the function $z_{n+1} = z_{n}^{2} + c$ as shown here.\nIn\u0026nbsp;[15]: @jit def holomorphic_julia_spinning_eyes(c, maxiter): z = c c = complex(-0.78, 0.1) for n in range(maxiter): if abs(z) \u0026gt; 10: return n z = z*z + c return 0 generate_image(holomorphic_julia_spinning_eyes, -1.5, 1.5, -1.5, 1.5)  Out[15]: \n\nThank you for reading!!! I hope this was a fun post.\n","date":1535414400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550351215,"objectID":"0a546997d0309bbdf022186f87b620d8","permalink":"https://nikstoyanov.me/post/2018-08-02-exploring-fractals/","publishdate":"2018-08-28T00:00:00Z","relpermalink":"/post/2018-08-02-exploring-fractals/","section":"post","summary":"Generating and exloring fractal structures with Python and Numba.","tags":["Python","Scipy","Numerical Analysis","Scientific Computing"],"title":"Exploring Fractals","type":"post"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.\n  Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using url_slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1483228800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550333982,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"https://nikstoyanov.me/talk/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example/","section":"talk","summary":"An example talk using Academic's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":null,"categories":null,"content":"","date":1461711600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550333982,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://nikstoyanov.me/project/external-project/","publishdate":"2016-04-27T00:00:00+01:00","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461711600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550333982,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"https://nikstoyanov.me/project/internal-project/","publishdate":"2016-04-27T00:00:00+01:00","relpermalink":"/project/internal-project/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Internal Project","type":"project"},{"authors":["GA Cushen"],"categories":null,"content":"More detail can easily be written here using Markdown and $\\rm \\LaTeX$ math code.\n","date":1441062000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550333982,"objectID":"d77fa4a74076ffcd7ca6c21cfc27a4b2","permalink":"https://nikstoyanov.me/publication/person-re-id/","publishdate":"2015-09-01T00:00:00+01:00","relpermalink":"/publication/person-re-id/","section":"publication","summary":"Person re-identification is a critical security task for recognizing a person across spatially disjoint sensors. Previous work can be computationally intensive and is mainly based on low-level cues extracted from RGB data and implemented on a PC for a fixed sensor network (such as traditional CCTV). We present a practical and efficient framework for mobile devices (such as smart phones and robots) where high-level semantic soft biometrics are extracted from RGB and depth data. By combining these cues, our approach attempts to provide robustness to noise, illumination, and minor variations in clothing. This mobile approach may be particularly useful for the identification of persons in areas ill-served by fixed sensors or for tasks where the sensor position and direction need to dynamically adapt to a target. Results on the BIWI dataset are preliminary but encouraging. Further evaluation and demonstration of the system will be available on our website.","tags":[],"title":"A Person Re-Identification System For Mobile Devices","type":"publication"},{"authors":["GA Cushen","MS Nixon"],"categories":null,"content":"More detail can easily be written here using Markdown and $\\rm \\LaTeX$ math code.\n","date":1372633200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550333982,"objectID":"2b4d919e3cf73dfcd0063c88fe01cb00","permalink":"https://nikstoyanov.me/publication/clothing-search/","publishdate":"2013-07-01T00:00:00+01:00","relpermalink":"/publication/clothing-search/","section":"publication","summary":"A mobile visual clothing search system is presented whereby a smart phone user can either choose a social networking image or capture a new photo of a person wearing clothing of interest and search for similar clothing in a large cloud-based ecommerce database. The phone's GPS location is used to re-rank results by retail store location, to inform the user of local stores where similar clothing items can be tried on.","tags":[],"title":"Mobile visual clothing search","type":"publication"},{"authors":null,"categories":null,"content":" Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = \\;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \nA fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears  Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view   Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links   night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links  Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1550333982,"objectID":"c2915ec5da95791851caafdcba9664af","permalink":"https://nikstoyanov.me/slides/example-slides/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/slides/example-slides/","section":"slides","summary":"Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$","tags":null,"title":"Slides","type":"slides"}]